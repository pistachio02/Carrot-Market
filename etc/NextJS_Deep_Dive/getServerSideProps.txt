~~~~~~~~~~~~

    웹/앱을 만들때 우리는 종종 로딩에 대해서 고민하게 된다.

    어떠한 페이지를 만들때 우리는 과연 유저에게 1) 모든것을 한꺼번에 보여주고싶은지,
    아니면 2) 필요한 데이터들이 불러와지는동안 전체적인 틀을 먼저 보여주고, 로딩중이라는 안내화면이나 문구가 잠시 나오다가 데이터가 불러와졌을때 데이터를 보여주게 될지.

    두가지의 방법 모두 가능한 방법이고 어느게 더 좋다 라고 딱 잘라 말할 수 없을것이다.
    상황에 따라 그에 맞는 방법을 사용하면 되는것이니까.
    그렇다면 우리는 이 두가지 방법 모두를 알고있을 필요가 있을까?
    당연히 알고있어야 한다.
    그래야 나중에 필요에 따라 두가지 방법 중 맞는 방법을 선택해 활용할 수 있을테니.

    getServerSideProps를 사용하면 위 말했던 방법 중 첫번째 방법을 할 수 있다.
    데이터가 불러와지길 기다리는게 아니라 우선적으로 필요한 모든것들을 불러오고 그 다음 유저에게 화면을 보여주게 되는데,
    이렇게 하면 위에서 말했듯 로딩화면은 없을거다.
    하나의 방법이긴 하지만 캐럿마켓을 생각하면 이렇게 했을때 단점이 생긴다.
    바로 useSWR을 사용할 수 없게 되는것이다.
    useSWR을 사용하면 데이터를 불러오고, 다른페이지에 갔다가 다시 돌아왔을때 그 데이터를 다시 요청을 보내서 가져오는게 아니라,
    기존에 받아놨던 데이터를 표시하고, 혹시나 데이터에 변경이 있는지를 확인해서 변경이 있을때만 다시 데이터를 받아오는 기능을 사용할 수 있었는데, 만약 getServerSideProps를 사용해서 코드를 작성하게 된다면 이러한 useSWR의 기능(캐시기능)을 사용할 수 없게 된다.

    또 다른 단점으로는 만약 혹시나 getServerSideProps 데이터를 fetch해오는 과정에서 오류가 나거나 문제가 생기게 된다면 유저는 아무런 화면도 볼 수 없게 될것이다. 

    그래서 우리는 항상 잘 선택을 해야한다.
    오류가 났을때 아무런 화면도 볼 수 없게 된다는 위험부담이 있지만 로딩화면 없이 데이터를 우선적으로 먼저 다 불러오고난 뒤 유저에게 화면을 보여줄지, 아니면 로딩하는 화면은 있을 수 있지만 오류가 나게되면 데이터는 없더라도 최소한의 UI를 유저에게 보여줄 수 있는 방식으로 코드를 작성해볼지.

    상황에 맞게, 또 우리가 기획하는 프로젝트에 맞게 잘 선택하면 될 일이다.

~~~~~~~~~~~~

    SSR + SWR

    그렇다면 과연 SSR을 사용하면서 useSWR의 기능들을 사용할수는 없을까?
    방법은 있다.

    우선 우리 캐럿마켓의 홈페이지인 상품목록 페이지를 예를들어보자.
    기존에는 클라이언트 사이드 렌더링으로 서버로 데이터 요청을 보내고 받아온 뒤 화면으로 데이터를 보여주는데,
    데이터를 받아오는동안 시간이 오래 걸린다면 로딩 화면을 보여주도록 코드를 짰다고 하자.

    이러한 구조에서 만약 SSR을 활용해 홈페이지를 작성하려면,
    SSR은 데이터를 우선 먼저 다 가져온 뒤 (그 사이 로딩화면 없이) 유저에게 데이터를 보여주게 되는데,
    이럴때에도 useSWR의 기능을 사용하고싶다면, 아래와 같이 하면 된다.

    우선 새로운 페이지를 만들고, 그 페이지 내부에서 기존 홈 페이지를 렌더링 시키면 된다.
    예를 들어 기존의 페이지 이름이 Home이었다면, 새로운 페이지를 만들고 그 안에서 Home을 렌더링 해주는 식이다.
    다만 그냥 바로 렌더링 하는것이 아닌 <SWRConfig /> 라는 태그 안에 위치시켜서 렌더링 해줘야 하는것인데,
    이때 또 그냥 그 안에 위치시키는것이 아닌 <SWRConfig /> 태그 안에 fallback이라는 설정을 해줘야 한다.

    만약 기존의 방법대로 useSWR을 활용해 캐시 기능을 사용했다면 관련된 설정을 위 설명한 fallback이라는 설정에 위치시켜줘야 이전처럼 캐시 기능을 사용할 수 있게 되는것이다.
    더 쉽게 얘기하자면 캐시라는것은 처음에는 비어있다가 데이터를 가져와 데이터가 생겼을때 캐시에 들어가게 되는것인데,
    SSR은 모든 데이터를 우선 불러온 뒤 코드를 실행시키고 화면에 보여주기 때문에 다른 페이지에 갔다가 오면 그렇게 이동했을때마다 늘 새롭게 데이터를 fetch했어야 했다.
    그런데 위 설명한 <SWRConfig /> 를 사용하면, 그리고 fallback 설정을 해주면,
    어떻게보면 SSR에서 모든 데이터를 불러오기 전에 먼저 필요한 데이터를 캐시에 집어넣어주는것이기 때문에
    이러한 캐시 기능이 가능하게 되는것이다.

    아래 새로운 페이지 관련 작성법을 예로 들어 한 번 작성해보았다.

    {/*

        const Page: NextPage<{ products: ProductWithCount[] }> = ({ products }) => {
            return (
                <SWRConfig
                value={{
                    fallback: {
                    "/api/products": {
                        ok: true,
                        products,
                    },
                    },
                }}
                >
                <Home />
                </SWRConfig>
            );
        };

        export async function getServerSideProps() {
            console.log("SSR");
            const products = await client.product.findMany({});
            return {
                props: {
                products: JSON.parse(JSON.stringify(products)),
                },
            };
        }

        export default Page;

    */}

    위 코드를 보면 새로운 페이지인 Page를 만들어 그 안에 <Home /> 을 렌더링 해주고 있다.
    물론 위 설명대로 <SWRConfig /> 안에 fallback 설정을 해줌으로써 다른페이지로 이동했다가 돌아오더라도 데이터를 새롭게 fetch하는것이 아닌 캐시에 있는 데이터를 활용해 화면에 보여주는 기능을 사용할 수 있게 된것이다.

~~~~~~~~~~~~

    SSR + Authentication은 조금 이해가 덜 되었다. 나중에 다시 들어보면 좋을 것 같다.
    우선 예시는 아래와 같다.

    {/*

        const Page: NextPage<{ profile: User }> = ({ profile }) => {
            return (
                <SWRConfig
                value={{
                    fallback: {
                    "/api/users/me": { ok: true, profile },
                    },
                }}
                >
                <Profile />
                </SWRConfig>
            );
        };

        export const getServerSideProps = withSsrSession(async function ({
            req,
        }: NextPageContext) {
            const profile = await client.user.findUnique({
                where: { id: req?.session.user?.id },
            });
            return {
                props: {
                profile: JSON.parse(JSON.stringify(profile)),
                },
            };
        });

        export default Page;

    */}

~~~~~~~~~~~~
